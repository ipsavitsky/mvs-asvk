# [MVS]Вступительное задание на кафедру АСВК
### Савицкий Илья, группа 208
## Сборка
Из заивисимостей - только библиотека для разбора XML файла `tinyXML2` которая включена.

Чтобы собрать все достаточно написать
```
make all
```
В результате сгенерируются три исполняемых файла: 
 - `mvs` - однопотчное решние задачи
 - `mvs_parallel` - многопоточное решение задачи
 - `config_generator` - генератор случайной конфигурации начальных условий

Очистка исполняемых файлов(и объектных файлов)

```
make clear
```

## Входные данные
Имя входного файла подается программе как часть аргумент командной строки. При подаче более одного файла все файлы после первого игнорируются.

### Строение XML файла
Каждый процессор в конфигурации задается следующим блоком
```xml
<processor>
    <max_load>70</max_load>
</processor>
```
где `<max_load>` - максимальная нагрузка на конкретный процессор
***
Каждый процесс в конфигурации задается следующим образом
```xml
<process>
    <load>10</load>
</process>
```
где `<load>` - нагрузка процесса на процессор
***
Каждое соединение в конфигурации описывается следующим образом
```xml
<connection>
    <first>35</first>
    <second>2</second>
    <load>10</load>
</connection>
```
где `<first>` - первый процесс который участвует в канале данных 

где `<second>` - второй процесс который участвует в канале данных

где `<load>` - нагрузка этого соединения на сеть
<!-- *** -->

## Основное зандание
Реализован алгоритм, приведенный в задании, вывод соответствует заданию

## Первое дополнительное задание
Реализован параллельный алгоритм.

На входных данных с 16 процессорами(измерено с помощью утилиты `time`)
 - Single thread
```
real    0m0.018s
user    0m0.018s
sys     0m0.000s
```
 - Multi thread
```
real    0m0.060s
user    0m0.683s
sys     0m0.020s
```

Как видно, время на создание потоков и на их синхронизацию доступа к критической секции сильно влияет но фаинальное время. Однако, надо учесть что при этом однопоточная программа обработала как минимум 1000 итераций, а многопоточная - как минимум 16000(16 потоков каждый из которых обрабатывает минимум 1000 итераций). Тогда если оценить производительность однопоточной программы которая обработает количество итераций сравнимое с многопоточной программой - появится ощутимый прирост в производительности. 

 - Single thread(16к)
```
real    0m0.218s
user    0m0.218s
sys     0m0.000s
```
